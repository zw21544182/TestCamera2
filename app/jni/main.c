/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class li_testcamera_JniUtil */

#ifndef _Included_li_testcamera_JniUtil
#define _Included_li_testcamera_JniUtil
#ifdef __cplusplus
extern "C" {
#endif
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <asm/types.h>
#include <linux/videodev2.h>
#include <sys/mman.h>
#include <string.h>
#include <malloc.h>
#include <linux/fb.h>
#include <jni.h>
#include <string.h>
#include <android/log.h>
#include <syslog.h>

#define  LOG_TAG    "zw-test"
#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG  , LOG_TAG, __VA_ARGS__)
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO   , LOG_TAG, __VA_ARGS__)
#define LOGW(...) __android_log_print(ANDROID_LOG_WARN   , LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR  , LOG_TAG, __VA_ARGS__)

typedef struct Buffers {
    char *start;
    unsigned int length;
} Buffers;

Buffers *buffers;
char *buffer_store;
int store_count = 0;
#define COUNTS        10
/*
 * Class:     li_testcamera_JniUtil
 * Method:    testmain
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_li_testcamera_JniUtil_testmain
  (JNIEnv *env, jclass obj){
     unsigned int uiLeft, uiTop, uiWidth, uiHeight;
      //unsigned int        uiFormat;
      enum v4l2_field Field;
      enum v4l2_buf_type Type;
      int ret = 0;
      uiLeft = 0;
      uiTop = 0;
      uiWidth = 1000;
      uiHeight = 720;
      FILE *pFile = fopen("2.yuv", "w");
      int fd = open("/dev/video1", O_RDWR);
  #if 0
      struct v4l2_capability cap;
      ret = ioctl(fd,VIDIOC_QUERYCAP,&cap);
      if (ret) {
              LOGI("QUREYCAP failed\n");
              ret = 0;
      }
      LOGI("DriverName:%s\nCard Name:%s\nBus info:%s\nDriverVersion:%u.%u.%u\n",cap.driver,cap.card,cap.bus_info,(cap.version>>16)&0xFF,(cap.version>>8)&0xFF,cap.version&0xFF);
  #endif

      Type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

      struct v4l2_cropcap cropcap;
      struct v4l2_crop crop;
      memset(&cropcap, 0, sizeof(cropcap));
      memset(&crop, 0, sizeof(crop));
      cropcap.type = Type;

      if (0 == ioctl(fd, VIDIOC_CROPCAP, &cropcap)) {
          crop.type = Type;
          //	crop.c = cropcap.defrect;

          crop.c.top = uiTop;
          crop.c.left = uiLeft;
          crop.c.height = uiHeight;
          crop.c.width = uiWidth;

          if (-1 == ioctl(fd, VIDIOC_S_CROP, &crop)) {
              switch (errno) {
                  case EINVAL:
                      break;
                  default:
                      break;
              }
              LOGI("client:VIDIOC_S_CROP Failed!\n");
              //		    return -1;
          }
      } else
          LOGI("client:VIDIOC_CROPCAP Failed!\n");


      struct v4l2_format fmt;
      memset(&fmt, 0, sizeof(fmt));
      fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
      ret = ioctl(fd, VIDIOC_G_FMT, &fmt);
      if (ret)
          LOGI("G_FMT failed\n");

      LOGI("##############width:%d\n\theight:%d\n", fmt.fmt.pix.width, fmt.fmt.pix.height);
      memset(&fmt, 0, sizeof(fmt));
      fmt.fmt.pix.width = uiWidth;
      fmt.fmt.pix.height = uiHeight;
      fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_NV12;
      //fmt.fmt.pix.pixelformat=V4L2_PIX_FMT_GREY;
      Field = V4L2_FIELD_INTERLACED;
      fmt.fmt.pix.field = Field;
      fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
      ret = ioctl(fd, VIDIOC_S_FMT, &fmt);
      if (ret)
          LOGI("S_FMT failed\n");

      ret = ioctl(fd, VIDIOC_G_FMT, &fmt);
      if (ret)
          LOGI("G_FMT failed\n");

      LOGI("\twidth:%d\n\theight:%d\n", fmt.fmt.pix.width, fmt.fmt.pix.height);

      struct v4l2_requestbuffers req;
      memset(&req, 0, sizeof(req));
      req.count = 4;
      req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
      req.memory = V4L2_MEMORY_MMAP;
      ioctl(fd, VIDIOC_REQBUFS, &req);
      LOGI("req.count = %d\n", req.count);

      buffers = (Buffers *) calloc(req.count, sizeof(Buffers));
      if (!buffers) {
          LOGI (stderr, "Out of memory/n");
          exit(EXIT_FAILURE);
      }
      buffer_store = (char *) calloc(1.5 * uiWidth * uiHeight * COUNTS, sizeof(char));
      if (!buffer_store) {
          LOGI (stderr, "Out of memory/n");
          exit(EXIT_FAILURE);
      }

      unsigned int n_buffers;
      for (n_buffers = 0; n_buffers < req.count; ++n_buffers) {
          struct v4l2_buffer buf;
          memset(&buf, 0, sizeof(buf));
          buffers[n_buffers].length = 0;
          buffers[n_buffers].start = 0;
          buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
          buf.memory = V4L2_MEMORY_MMAP;
          buf.index = n_buffers;
          // 查询序号为n_buffers 的缓冲区，得到其起始物理地址和大小
          if (-1 == ioctl(fd, VIDIOC_QUERYBUF, &buf))
              exit(-1);
          buffers[n_buffers].length = buf.length;
          LOGI("BUF %d",buf.length);
          // 映射内存
          buffers[n_buffers].start = (char*)mmap(NULL, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd,
                                          buf.m.offset);
          if (MAP_FAILED == buffers[n_buffers].start)
              exit(-1);

          if(ioctl(fd, VIDIOC_DQBUF, &buf)<0){
              LOGI("FAUSE");
          }else {
          }
          LOGI("start %d, %x\n", n_buffers, buffers[n_buffers].start);
      }

      unsigned int i;
      enum v4l2_buf_type type;
      // 将缓冲帧放入队列
      for (i = 0; i < req.count; ++i) {
          struct v4l2_buffer buf;
          memset(&buf, 0, sizeof(buf));
          buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
          buf.memory = V4L2_MEMORY_MMAP;
          buf.index = i;
      }
      type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
      if (ioctl(fd, VIDIOC_STREAMON, &type)) {
          LOGI("stream on error\n");
      } else
          LOGI("stream on...\n");
      for (i = 0; i < COUNTS; i++) {
          struct v4l2_buffer buf;
          memset(&buf, 0, sizeof(buf));
          buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
          buf.memory = V4L2_MEMORY_MMAP;
          LOGI("dqbuf, \n");
          // 从缓冲区取出一个缓冲帧

          if(ioctl(fd, VIDIOC_DQBUF, &buf)<0)
          {
              LOGI("FAULSE");
          }
          else
          {
              LOGI("SUCESS");};
          LOGI("dqbuf, done , index %d \n", buf.index);
          // 图像处理
  //        memcpy(buffer_store + store_count * uiWidth * uiHeight, buffers[buf.index].start,
  //               buffers[buf.index].length);
  //        LOGI("length %d\n", buffers[buf.index].length);
  //        fwrite(buffer_store + store_count * uiWidth * uiHeight * 3 / 2, uiWidth * uiHeight * 1.5, 1,
  //               pFile);
          store_count++;
          LOGI("qbuf, \n");
          // 将取出的缓冲帧放回缓冲区
          ioctl(fd, VIDIOC_QBUF, &buf);
          LOGI("qbuf, done \n");
      }

      type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
      if (-1 == ioctl(fd, VIDIOC_STREAMOFF, &type)) {
          LOGI("off error\n");
      }
  #if 0
          for (i = 0; i < COUNTS; i++) {
                  fwrite(buffer_store + i * uiWidth*uiHeight , uiWidth*uiHeight, 1, pFile);
          }
  #endif
      LOGI("pFile write done\n");
      fclose(pFile);


      free(buffers);
      free(buffer_store);

      close(fd);
      return 0;


  };

#ifdef __cplusplus
}
#endif
#endif
